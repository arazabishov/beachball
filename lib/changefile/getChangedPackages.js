"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const paths_1 = require("../paths");
const git_1 = require("../git");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const getScopedPackages_1 = require("../monorepo/getScopedPackages");
/**
 * Gets all the changed packages, regardless of the change files
 */
function getAllChangedPackages(options) {
    const { branch, path: cwd } = options;
    const changes = [...(git_1.getChanges(branch, cwd) || []), ...(git_1.getStagedChanges(branch, cwd) || [])];
    const scopedPackages = getScopedPackages_1.getScopedPackages(options);
    const ignoredFiles = ['CHANGELOG.md', 'CHANGELOG.json'];
    const packageRoots = {};
    if (changes) {
        // Discover package roots from modded files (ignores the CHANGELOG file because that's generated by beachball)
        changes
            .filter(name => !ignoredFiles.includes(path_1.default.basename(name)))
            .forEach(moddedFile => {
            const root = paths_1.findPackageRoot(path_1.default.join(cwd, path_1.default.dirname(moddedFile)));
            if (root && !packageRoots[root]) {
                try {
                    const packageJson = fs_extra_1.default.readJSONSync(path_1.default.join(root, 'package.json'));
                    if (!packageJson.private && (!packageJson.beachball || packageJson.beachball.shouldPublish !== false)) {
                        const packageName = packageJson.name;
                        if (scopedPackages.includes(packageName)) {
                            packageRoots[root] = packageName;
                        }
                    }
                }
                catch (e) {
                    // Ignore JSON errors
                }
            }
        });
    }
    return Object.values(packageRoots);
}
/**
 * Gets all the changed packages, accounting for change files
 */
function getChangedPackages(options) {
    const { fetch, path: cwd, branch } = options;
    const changePath = paths_1.getChangePath(cwd);
    if (fetch) {
        const { remote, remoteBranch } = git_1.parseRemoteBranch(branch);
        console.log(`fetching latest from remotes "${remote}/${remoteBranch}"`);
        git_1.fetchRemote(remote, remoteBranch, cwd);
    }
    const changedPackages = getAllChangedPackages(options);
    const changeFilesResult = git_1.git(['diff', '--name-only', '--no-renames', '--diff-filter=A', `${branch}...`], { cwd });
    if (!changePath || !fs_extra_1.default.existsSync(changePath) || !changeFilesResult.success) {
        return changedPackages;
    }
    const changes = changeFilesResult.stdout.split(/\n/);
    const changeFiles = changes.filter(name => path_1.default.dirname(name) === 'change');
    const changeFilePackageSet = new Set();
    // Loop through the change files, building up a set of packages that we can skip
    changeFiles.forEach(file => {
        try {
            const changeInfo = fs_extra_1.default.readJSONSync(file);
            changeFilePackageSet.add(changeInfo.packageName);
        }
        catch (e) {
            console.warn(`Invalid change file encountered: ${file}`);
        }
    });
    if (changeFilePackageSet.size > 0) {
        console.log('Your local repository already has change files for these packages:' +
            [...changeFilePackageSet]
                .sort()
                .map(pkg => `\n  ${pkg}`)
                .join(''));
    }
    return changedPackages.filter(pkgName => !changeFilePackageSet.has(pkgName));
}
exports.getChangedPackages = getChangedPackages;
//# sourceMappingURL=getChangedPackages.js.map